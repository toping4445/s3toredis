
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Manifold: the main class &#8212; SnapPy 3.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ManifoldHP: High-precision variant" href="manifoldhp.html" />
    <link rel="prev" title="The snappy module and its classes" href="snappy.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifoldhp.html" title="ManifoldHP: High-precision variant"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="snappy.html" title="The snappy module and its classes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 3.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="snappy.html" accesskey="U">The snappy module and its classes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Manifold: the main class</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="manifold-the-main-class">
<h1>Manifold: the main class<a class="headerlink" href="#manifold-the-main-class" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="snappy.Manifold">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">snappy.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold" title="Permalink to this definition">¶</a></dt>
<dd><p>A Manifold is a Triangulation together with a geometric structure.
That is, a Manifold is an ideal triangulation of the interior of a
compact 3-manifold with torus boundary, where each tetrahedron has
has been assigned the geometry of an ideal tetrahedron in
hyperbolic 3-space.  A Dehn-filling can be specified for each
boundary component, allowing the description of closed 3-manifolds
and some orbifolds.   Here’s a quick example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>  
<span class="go">4.05686022</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> 
<span class="go">[-4.278936315 + 1.95728679*I]</span>
</pre></div>
</div>
<p>A Manifold can be specified in a number of ways, e.g.</p>
<ul class="simple">
<li><p>Manifold(‘9_42’) : The complement of the knot 9_42 in S^3.</p></li>
<li><p>Manifold(‘m125(1,2)(4,5)’) : The SnapPea census manifold m125
where the first cusp has Dehn filling (1,2) and the second cusp has
filling (4,5).</p></li>
<li><p>Manifold() : Opens a link editor window where can you
specify a link complement.</p></li>
</ul>
<p>In general, the specification can be from among the below, with
information on Dehn fillings added.</p>
<ul>
<li><p>SnapPea cusped census manifolds: e.g. ‘m123’, ‘s123’, ‘v123’.</p></li>
<li><dl class="simple">
<dt>Link complements:</dt><dd><ul class="simple">
<li><p>Rolfsen’s table: e.g. ‘4_1’, ‘04_1’, ‘5^2_6’, ‘6_4^7’, ‘L20935’, ‘l104001’.</p></li>
<li><p>Hoste-Thistlethwaite Knotscape table:  e.g. ‘11a17’ or ‘12n345’</p></li>
<li><p>Callahan-Dean-Weeks-Champanerkar-Kofman-Patterson knots: e.g. ‘K6_21’.</p></li>
<li><p>Dowker-Thistlethwaite code: e.g. ‘DT:[(6,8,2,4)]’</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Once-punctured torus bundles: e.g. ‘b++LLR’, ‘b+-llR’, ‘bo-RRL’, ‘bn+LRLR’</p></li>
<li><p>Fibered manifold associated to a braid: ‘Braid[1,2,-3,4]’</p>
<p>Here, the braid is thought of as a mapping class of the
punctured disc, and this manifold is the corresponding
mapping torus.  If you want the braid closure, do (1,0) filling
of the last cusp.</p>
</li>
<li><p>From mapping class group data using Twister:</p>
<p>‘Bundle(S_{1,1}, [a0, B1])’ or ‘Splitting(S_{1,0}, [b1, A0], [a0,B1])’</p>
<p>See the help for the ‘twister’ module for more.</p>
</li>
<li><p>A SnapPea triangulation or link projection file: ‘filename’</p>
<p>The file will be loaded if found in the current directory or the
path given by the shell variable SNAPPEA_MANIFOLD_DIRECTORY.</p>
</li>
<li><p>A string containing the contents of a SnapPea triangulation or link
projection file.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.DT_code">
<span class="sig-name descname"><span class="pre">DT_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flips</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.DT_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dowker-Thistlethwaite code of this link complement,
if it is a link complement. The DT code is intended to be an
immutable attribute, for use with knot and link exteriors
only, which is set only when the manifold was created.</p>
<p>Here is the Whitehead link:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L5a1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">()</span>
<span class="go">[(6, 8), (2, 10, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flips</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb.01110&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">flips</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([(6, 8), (2, 10, 4)], [0, 1, 1, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.alexander_polynomial">
<span class="sig-name descname"><span class="pre">alexander_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.alexander_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the multivariable Alexander polynomial of the manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K12n123&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">34</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">45</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">34</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span>

<span class="n">sage</span><span class="p">:</span> <span class="n">N</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;v1539(5,1)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="n">a</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>Any provided keyword arguments are passed to fundamental_group and
so affect the group presentation used in the computation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.browse">
<span class="sig-name descname"><span class="pre">browse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.browse" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">browse</span><span class="p">()</span> <span class="c1"># Opens browser window  </span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.canonical_retriangulation">
<span class="sig-name descname"><span class="pre">canonical_retriangulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_bits_precs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[53,</span> <span class="pre">212]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_bits_prec_and_degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[(212,</span> <span class="pre">10),</span> <span class="pre">(1000,</span> <span class="pre">20),</span> <span class="pre">(2000,</span> <span class="pre">20)]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.canonical_retriangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>The canonical retriangulation which is closely related to the canonical
cell decomposition and described in more detail <a class="reference external" href="verify.html#the-canonical-retriangulation-and-the-isometry-signature">here</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="c1"># Unverified size of the isometry group.</span>
<span class="go">8</span>
</pre></div>
</div>
<p>When used inside <a class="reference external" href="http://sagemath.org/">Sage</a> and <code class="docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> is
passed as argument, the verify module will certify the result to be
correct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="c1"># Verified size of the isometry group.</span>
<span class="mi">8</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="verify_canon.html#snappy.verify.verified_canonical_retriangulation" title="snappy.verify.verified_canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify.verified_canonical_retriangulation()</span></code></a> for the
additional options.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.canonize">
<span class="sig-name descname"><span class="pre">canonize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.canonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the triangulation to an arbitrary retriangulation of
the canonical cell decomposition.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">canonize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note: due to rounding error, it is possible that this is not
actually the canonical triangulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.chern_simons">
<span class="sig-name descname"><span class="pre">chern_simons</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.chern_simons" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Chern-Simons invariant of the manifold, if it is known.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">-0.15320413</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which
is the number of digits of accuracy as <em>estimated</em> by SnapPea.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span><span class="o">.</span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">56</span><span class="p">)</span> <span class="c1"># Low and High precision</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, when the manifold has at least one cusp, Zickert’s
algorithm is used; when the manifold is closed we use SnapPea’s
original algorithm, which is based on Meyerhoff-Hodgson-Neumann.</p>
<p>Note: When computing the Chern-Simons invariant of a closed
manifold, one must sometimes compute it first for the unfilled
manifold so as to initialize SnapPea’s internals.  For instance,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">-0.15320413</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">0.07731787</span>
</pre></div>
</div>
<p>works, but will fail with ‘Chern-Simons invariant not
currently known’ if the first call to chern_simons is not
made.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.complex_volume">
<span class="sig-name descname"><span class="pre">complex_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verified_modulo_2_torsion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.complex_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex volume, i.e.
volume + i 2 pi^2 (chern simons)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span> 
<span class="go">2.82812209 - 3.02412838*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span> 
<span class="go">2.22671790 + 1.52619361*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;3_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> 
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span> 
<span class="go">-1.64493407</span>
</pre></div>
</div>
<p>If no cusp is filled or there is only one cusped (filled or
unfilled), the complex volume can be verified up to multiples
of i pi^2 / 2 by passing <cite>verified_modulo_2_torsion = True</cite>
when inside SageMath (and higher precision can be requested
with <cite>bits_prec</cite>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m015&quot;)
sage: M.complex_volume(verified_modulo_2_torsion=True, bits_prec = 90) # doctest: +NUMERIC24
2.828122088330783162764? + 1.910673824035377649698?*I
sage: M = Manifold(&quot;m015(3,4)&quot;)
sage: M.complex_volume(verified_modulo_2_torsion=True) # doctest: +NUMERIC6
2.625051576? - 0.537092383?*I
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the manifold</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cover">
<span class="sig-name descname"><span class="pre">cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">permutation_rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cover" title="Permalink to this definition">¶</a></dt>
<dd><p>M.cover(permutation_rep)</p>
<p>Returns a Manifold representing the finite cover
specified by a transitive permutation representation.  The
representation is specified by a list of permutations, one for
each generator of the simplified presentation of the
fundamental group.  Each permutation is specified as a list P
such that set(P) == set(range(d)) where d is the degree of the
cover.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N0</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">N0</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0000000001</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If within Sage, the permutations can also be of type
PermutationGroupElement, in which case they act on the set
range(1, d + 1).  Or, you can specify a GAP or Magma subgroup
of the fundamental group.     Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The basic method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N0</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
<p>From a Gap subgroup:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">gap</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">())</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">LowIndexSubgroupsFpGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)[</span><span class="mi">9</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N0</span> <span class="o">==</span> <span class="n">N1</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>Or a homomorphism to a permutation group:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">GQuotients</span><span class="p">(</span><span class="n">PSL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="mf">8.00000000</span>
</pre></div>
</div>
<p>Or maybe we want larger cover coming from the kernel of this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N3</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">())</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N3</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="mf">168.00000000</span>
</pre></div>
</div>
<p>Check the homology against what Gap computes directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N3</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span><span class="o">.</span><span class="n">betti_number</span><span class="p">()</span>
<span class="mi">32</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">()</span><span class="o">.</span><span class="n">AbelianInvariants</span><span class="p">()</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
<span class="mi">32</span>
</pre></div>
</div>
<p>We can do the same for Magma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">magma</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">())</span>             <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Q</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">pQuotient</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nvals</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>          <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">())</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>                 <span class="c1">#doctest: +SKIP</span>
<span class="mf">10.14941606</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">h</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">SimpleQuotients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N4</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>                              <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span> <span class="o">==</span> <span class="n">N4</span>                                     <span class="c1">#doctest: +SKIP</span>
<span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cover_info">
<span class="sig-name descname"><span class="pre">cover_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cover_info" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is a manifold or triangulation which was constructed as
a covering space, return a dictionary describing the cover.  Otherwise
return 0.  The dictionary keys are ‘base’, ‘type’ and ‘degree’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.covers">
<span class="sig-name descname"><span class="pre">covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cover_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>M.covers(degree, method=None)</p>
<p>Returns a list of Manifolds corresponding to all of the
finite covers of the given degree.</p>
<p>WARNING: If the degree is large this might take a very, very,
very long time.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">())</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">]</span>
<span class="go">[(m003~irr~0(0,0)(0,0), Z/5 + Z + Z), (m003~cyc~1(0,0), Z/3 + Z/15 + Z)]</span>
</pre></div>
</div>
<p>You can also look just at cyclic covers, which is much faster.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s1">&#39;cyclic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">())</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">]</span>
<span class="go">[(m003~cyc~0(0,0), Z/3 + Z/15 + Z)]</span>
</pre></div>
</div>
<p>If you are using Sage, you can use GAP to find the subgroups,
which is often much faster, by specifying the optional
argument method = ‘gap’ If you have Magma installed, you can
used it to do the heavy lifting by specifying method=’magma’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_area_matrix">
<span class="sig-name descname"><span class="pre">cusp_area_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trigDependentTryCanonize'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_area_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a matrix that can be used to check whether
cusp neighborhoods of areas a<sub>0</sub>, …, a<sub>m-1</sub> are
disjoint: the cusp neighborhoods about cusp i and j are
disjoint (respectively, the cusp neighborhood embeds if i and j
are equal) if a<sub>i</sub> * a<sub>j</sub> is less than or equal to
the entry (i,j) of the cusp area matrix. Note that the “if”
becomes “if and only if” if we pick the “maximal cusp area
matrix”.</p>
<p>This function can operate in different ways (determined by
<code class="docutils literal notranslate"><span class="pre">method</span></code>). By default (<code class="docutils literal notranslate"><span class="pre">method='trigDependentTryCanonize'</span></code>),
it returns a result which can be suboptimal and non-deterministic
but is quicker to compute and sufficies for many applications:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;s776&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_area_matrix</span><span class="p">()</span> 
<span class="go">[28.0000000000000 7.00000000000000 6.99999999999999]</span>
<span class="go">[7.00000000000000 21.4375000000000 7.00000000000000]</span>
<span class="go">[6.99999999999999 7.00000000000000 21.4375000000000]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">method='maximal'</span></code> is specified, the result is the “maximal
cusp area matrix”, thus it is optimal and an invariant of the
manifold with labeled cusps. Note that the “maximal cusp area
matrix” is only available as verified computation and thus
requires passing <code class="docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_area_matrix(method = &#39;maximal&#39;, verified=True) # doctest: +NUMERIC6
[28.0000000000?  7.0000000000?  7.0000000000?]
[ 7.0000000000?  28.000000000? 7.00000000000?]
[ 7.0000000000? 7.00000000000?   28.00000000?]
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> is specified and <code class="docutils literal notranslate"><span class="pre">method</span></code> is not
<code class="docutils literal notranslate"><span class="pre">maximal</span></code>, the entries are all guaranteed to be less than the
corresponding ones in the maximal cusp area matrix (more
precisely, the lower end point of the interval is guaranteed to be
less than the true value of the corresponding maximal cusp area
matrix entry):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_area_matrix(verified=True, bits_prec=70) # doctest: +NUMERIC15
[ 28.000000000000000?  7.0000000000000000?  7.0000000000000000?]
[ 7.0000000000000000? 21.4375000000000000?  7.0000000000000000?]
[ 7.0000000000000000?  7.0000000000000000? 21.4375000000000000?]
</pre></div>
</div>
<p>For expert users:</p>
<p>Besides the two values above, <code class="docutils literal notranslate"><span class="pre">method</span></code> can be <code class="docutils literal notranslate"><span class="pre">trigDependent</span></code>:
this result is also fast to compute by making the assumption that
cusp neighborhoods are not only disjoint but also in “standard
form” with respect to the triangulation (i.e., when lifting of a
cusp neighborhood to a horoball in the universal cover, it
intersects a geodesic tetrahedron in three but not four
faces). <code class="docutils literal notranslate"><span class="pre">trigDependentTryCanonize</span></code> is similar to
<code class="docutils literal notranslate"><span class="pre">trigDependent</span></code> but tries to “proto-canonize” (a copy of) the
triangulation first since this often produces a matrix that is
closer to the maximal cusp area matrix, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;o9_35953&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_area_matrix</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;trigDependent&#39;</span><span class="p">)</span> 
<span class="go">[72.9848715318467 12.7560424258060]</span>
<span class="go">[12.7560424258060 6.65567118002656]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_area_matrix</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;trigDependentTryCanonize&#39;</span><span class="p">)</span> 
<span class="go">[72.9848715318466 12.7560424258060]</span>
<span class="go">[12.7560424258060 62.1043047674605]</span>
</pre></div>
</div>
<p>Compare to maximal area matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_area_matrix(method = &#39;maximal&#39;, verified = True, bits_prec = 100) # doctest: +NUMERIC15
[       72.984871531846664? 12.7560424258059765562778?]
[12.7560424258059765562778?     62.104304767460978078?]
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_areas">
<span class="sig-name descname"><span class="pre">cusp_areas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trigDependentTryCanonize'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks areas for the cusps such that the corresponding cusp
neighborhoods are disjoint. By default, the <code class="docutils literal notranslate"><span class="pre">policy</span></code> is
<code class="docutils literal notranslate"><span class="pre">unbiased</span></code> which means that the cusp neighborhoods are blown up
simultaneously with a cusp neighborhood stopping to grow when it
touches another cusp neighborhood or itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;s776&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">()</span> 
<span class="go">[2.64575131106459, 2.64575131106459, 2.64575131106459]</span>
</pre></div>
</div>
<p>Alternatively, <code class="docutils literal notranslate"><span class="pre">policy='greedy'</span></code> means that the first cusp
neighborhood is blown up until it touches itself, then the second
cusp neighborhood is blown up until it touches itself or the first
cusp neighborhood, …:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span> 
<span class="go">[5.29150262212918, 1.32287565553230, 1.32287565553229]</span>
</pre></div>
</div>
<p>To specify cusps to be blown up first, and in which order to blow
them up, set <code class="docutils literal notranslate"><span class="pre">first_cusps</span></code> to the appropriate list of cusps.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;o9_44210&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span> 
<span class="go">[7.053940530873898, 3.2712450270, 2.7091590087]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[])</span> 
<span class="go">[7.053940530873898, 3.2712450270, 2.7091590087]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,])</span> 
<span class="go">[7.053940530873898, 3.2712450270, 2.7091590087]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> 
<span class="go">[7.053940530873898, 3.2712450270, 2.7091590087]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
<span class="go">[7.053940530873898, 3.2712450270, 2.7091590087]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> 
<span class="go">[7.053940530873898, 2.3513135103, 3.7690945490]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,])</span> 
<span class="go">[4.0302253322, 5.725527974287718, 1.5478612583]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cusp_areas</span></code> is implemented using
<a class="reference internal" href="#snappy.Manifold.cusp_area_matrix" title="snappy.Manifold.cusp_area_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.cusp_area_matrix()</span></code></a> and the same arguments
(<code class="docutils literal notranslate"><span class="pre">method</span></code>, <code class="docutils literal notranslate"><span class="pre">verified</span></code>, <code class="docutils literal notranslate"><span class="pre">bits_prec</span></code>) are accepted. For
example, verified computations are supported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M=Manifold(&quot;v2854&quot;)
sage: M.cusp_areas(verified=True) # doctest: +NUMERIC9
[3.6005032476?, 3.6005032476?]
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">method='maximal'</span></code>, <code class="docutils literal notranslate"><span class="pre">policy='unbiased'</span></code> and
<code class="docutils literal notranslate"><span class="pre">verified=True</span></code>, the result is an invariant of the manifold with
labeled cusps and the corresponding cusp neighborhoods are maximal
in that every cusp neighborhood is touching some (not necessarily
distinct) cusp neighborhood.</p>
<p>Area of the cusp neighborhood touching itself for a one-cusped
manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M=Manifold(&quot;v1959&quot;)
sage: M.cusp_areas(method=&#39;maximal&#39;, verified=True, bits_prec=100) # doctest: +NUMERIC15
[7.15679216175810579?]
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_info">
<span class="sig-name descname"><span class="pre">cusp_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_spec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an info object containing information about the given
cusp.   Usage:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3227(0,0)(1,2)(3,2)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Cusp 1 : torus cusp with Dehn filling coefficients (M, L) = (1.0, 2.0)</span>
</pre></div>
</div>
<p>To get more detailed information about the cusp, we do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">0.11044502 + 0.94677098*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">modulus</span>
<span class="go">-0.12155872 + 1.04204128*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;filling&#39;, &#39;holonomies&#39;, &#39;holonomy_accuracy&#39;, &#39;index&#39;, &#39;is_complete&#39;, &#39;modulus&#39;, &#39;shape&#39;, &#39;shape_accuracy&#39;, &#39;topology&#39;]</span>
</pre></div>
</div>
<p>Here ‘shape’ is the shape of the cusp, i.e.
(longitude/meridian)
and ‘modulus’ is its shape in the geometrically preferred
basis, i.e.
( (second shortest translation)/(shortest translation)).
For cusps that are filled, one instead cares about the
holonomies:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;holonomies&#39;</span><span class="p">]</span>
<span class="go">(-0.59883089 + 1.09812548*I, 0.89824633 + 1.49440443*I)</span>
</pre></div>
</div>
<p>The complex numbers returned for the shape and for the two
holonomies have an extra attribute, accuracy, which is
SnapPea’s <em>estimate</em> of their accuracy.</p>
<p>You can also get information about multiple cusps at once:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">()</span>
<span class="go">[Cusp 0 : complete torus cusp of shape 0.11044502 + 0.94677098*I,</span>
<span class="go"> Cusp 1 : torus cusp with Dehn filling coefficients (M, L) = (1.0, 2.0),</span>
<span class="go"> Cusp 2 : torus cusp with Dehn filling coefficients (M, L) = (3.0, 2.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;is_complete&#39;</span><span class="p">)</span>
<span class="go">[True, False, False]</span>
</pre></div>
</div>
<p>The cusp shapes can be verified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&#39;m292&#39;)
sage: M.cusp_info(&#39;shape&#39;, verified = True, bits_prec = 60) # doctest: +NUMERIC12
[-0.1766049820997? + 1.2028208192855?*I,
 -0.1766049820997? + 1.2028208192855?*I]
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_neighborhood">
<span class="sig-name descname"><span class="pre">cusp_neighborhood</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns information about the cusp neighborhoods of the
manifold, in the form of data about the corresponding horoball
diagrams in hyperbolic 3-space.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;s000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_neighborhood</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">0.32475953</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">CN</span><span class="o">.</span><span class="n">horoballs</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
<span class="go">178</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>  <span class="c1"># Opens picture of the horoballs  </span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_translations">
<span class="sig-name descname"><span class="pre">cusp_translations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trigDependentTryCanonize'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_translations" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks disjoint cusp neighborhoods and returns the respective
(complex) Euclidean translations of the meridian and longitude for
each cusp. The method takes the same arguments as
<a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.cusp_areas()</span></code></a> and uses that method to pick the
cusp neighborhood. The result is a list of pairs, the second entry
corresponding to a longitude is always real:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;s776&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_translations</span><span class="p">()</span> 
<span class="go">[(0.500000000000000 + 1.32287565553230*I, 2.00000000000000), (0.500000000000000 + 1.32287565553230*I, 2.00000000000000), (0.499999999999999 + 1.32287565553230*I, 2.00000000000000)]</span>
</pre></div>
</div>
<p>Arguments such as <code class="docutils literal notranslate"><span class="pre">policy='greedy'</span></code> are interpreted the same way as
for <a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.cusp_areas()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_translations</span><span class="p">(</span><span class="n">policy</span> <span class="o">=</span> <span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">bits_prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> 
<span class="go">[(0.70710678118654752440084436210 + 1.8708286933869706927918743662*I, 2.8284271247461900976033774484), (0.35355339059327376220042218105 + 0.93541434669348534639593718308*I, 1.4142135623730950488016887242), (0.35355339059327376220042218105 + 0.93541434669348534639593718308*I, 1.4142135623730950488016887242)]</span>
</pre></div>
</div>
<p>and can return verified intervals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_translations(method = &#39;maximal&#39;, verified = True) # doctest: +NUMERIC9
[(0.50000000000? + 1.32287565553?*I, 2.00000000000?), (0.500000000000? + 1.32287565554?*I, 2.00000000000?), (0.500000000000? + 1.32287565554?*I, 2.00000000000?)]
</pre></div>
</div>
<p>that are guaranteed to contain the true translations of cusp neighborhoods
verified to be disjoint (the element corresponding to a longitude
is always in a <code class="docutils literal notranslate"><span class="pre">RealIntervalField</span></code>).</p>
<p><strong>Remark:</strong> The default <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'trigDependentTryCanonize'</span></code> is
(potentially) non-deterministic and thus the result of</p>
<blockquote>
<div><p>[ M.cusp_translations()[i] for i in range(M.num_cusps()) ]</p>
</div></blockquote>
<p>might not correspond to disjoint cusp neighborhoods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dehn_fill">
<span class="sig-name descname"><span class="pre">dehn_fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filling_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dehn_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Dehn filling coefficients of the cusps.  This can be
specified in the following ways, where the cusps are numbered
by 0,1,…,(num_cusps - 1).</p>
<ul>
<li><p>Fill cusp 2:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;8^4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(0,0)</span>
</pre></div>
</div>
</li>
<li><p>Fill the last cusp:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p>Fill the first two cusps:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(3,0)(1,-4)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p>When there is only one cusp, there’s a shortcut</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m004(-3,4)</span>
</pre></div>
</div>
</li>
</ul>
<p>Does not return a new Manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dirichlet_domain">
<span class="sig-name descname"><span class="pre">dirichlet_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default_vertex_epsilon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_at_origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize_injectivity_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dirichlet_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a DirichletDomain object representing a Dirichlet
domain of the hyperbolic manifold, typically centered at a
point which is a local maximum of injectivity radius.  It will
have ideal vertices if the manifold is not closed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>   <span class="c1">#Shows 3d-graphical view.  </span>
</pre></div>
</div>
<p>Other options can be provided to customize the computation;
the default choices are shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">vertex_epsilon</span><span class="o">=</span><span class="mf">10.0</span><span class="o">**-</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>   <span class="n">displacement</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">... </span>   <span class="n">centroid_at_origin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maximize_injectivity_radius</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
</pre></div>
</div>
<p>Here’s one with different combinatorics:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">displacement</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="n">maximize_injectivity_radius</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span>
<span class="go">44 finite vertices, 1 ideal vertices; 69 edges; 26 faces</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.drill">
<span class="sig-name descname"><span class="pre">drill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">which_curve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.drill" title="Permalink to this definition">¶</a></dt>
<dd><p>Drills out the specified dual curve from among all dual curves
with at most max_segments, which defaults to 6. The method
dual_curve allows one to see the properties of curves before
choosing which one to drill out.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_segments</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dual_curves">
<span class="sig-name descname"><span class="pre">dual_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dual_curves" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <em>reasonable</em> selection of simple closed curves in
a manifold’s dual 1-skeleton.  In particular, it returns those
that appear to represent geodesics. The resulting curves can
be drilled out.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span>
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I,</span>
<span class="go">   1: orientation-preserving curve of length 1.12479830 + 0.65232354*I,</span>
<span class="go">   2: orientation-preserving curve of length 1.26080402 + 1.97804689*I,</span>
<span class="go">   3: orientation-preserving curve of length 1.58826933 + 1.67347167*I,</span>
<span class="go">   4: orientation-preserving curve of length 1.68719745 + 2.81543089*I]</span>
</pre></div>
</div>
<p>Each curve is returned as an info object with these keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;complete_length&#39;, &#39;filled_length&#39;, &#39;index&#39;, &#39;max_segments&#39;, &#39;parity&#39;]</span>
</pre></div>
</div>
<p>We can drill out any of these curves to get a new manifold
with one more cusp.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>By default, this function only finds curves of length 6; this
can be changed by specifying the optional argument
max_segments</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">(</span><span class="n">max_segments</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.edge_valences">
<span class="sig-name descname"><span class="pre">edge_valences</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.edge_valences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary whose keys are the valences of the edges
in the triangulation, and the value associated to a key is the
number of edges of that valence.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;v3227&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">edge_valences</span><span class="p">()</span>     
<span class="go">{10: 1, 4: 1, 5: 2, 6: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.filled_triangulation">
<span class="sig-name descname"><span class="pre">filled_triangulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusps_to_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.filled_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Manifold where the specified cusps have been
permanently filled in.</p>
<p>Filling all the cusps results in a Triangulation rather
than a Manifold, since SnapPea can’t deal with hyperbolic
structures when there are no cusps.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125(1,2)(3,4)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Filling cusps 0 and 2 :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3227(1,2)(3,4)(5,6)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">v3227_filled(3,4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.fundamental_group">
<span class="sig-name descname"><span class="pre">fundamental_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplify_presentation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillings_may_affect_generators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimize_number_of_generators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_hard_to_shorten_relators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.fundamental_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a HolonomyGroup representing the fundamental group of
the manifold, together with its holonomy representation.  If
integer Dehn surgery parameters have been set, then the
corresponding peripheral elements are killed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span>
<span class="go">Generators:</span>
<span class="go">   a,b</span>
<span class="go">Relators:</span>
<span class="go">   aaabABBAb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">peripheral_curves</span><span class="p">()</span>
<span class="go">[(&#39;ab&#39;, &#39;aBAbABab&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">SL2C</span><span class="p">(</span><span class="s1">&#39;baaBA&#39;</span><span class="p">)</span>
<span class="go">[ 2.50000000 - 2.59807621*I -6.06217783 - 0.50000000*I]</span>
<span class="go">[ 0.86602540 - 2.50000000*I -4.00000000 + 1.73205081*I]</span>
</pre></div>
</div>
<p>There are three optional arguments all of which default to True:</p>
<ul class="simple">
<li><p>simplify_presentation</p></li>
<li><p>fillings_may_affect_generators</p></li>
<li><p>minimize_number_of_generators</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">Generators:</span>
<span class="go">   a,b,c</span>
<span class="go">Relators:</span>
<span class="go">   CbAcB</span>
<span class="go">   BacA</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.gluing_equations">
<span class="sig-name descname"><span class="pre">gluing_equations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>In the default mode, this function returns a matrix with rows
of the form</p>
<blockquote>
<div><p>a b c  d e f  …</p>
</div></blockquote>
<p>which means</p>
<blockquote>
<div><p>a*log(z0) + b*log(1/(1-z0)) + c*log((z0-1)/z0) + d*log(z1) +… = 2 pi i</p>
</div></blockquote>
<p>for an edge equation, and (same) = 0 for a cusp equation.
Here, the cusp equations come at the bottom of the matrix, and
are listed in the form: meridian of cusp 0, longitude of cusp
0, meridian of cusp 1, longitude of cusp 1,…</p>
<p>In terms of the tetrahedra, a is the invariant of the edge
(2,3), b the invariant of the edge (0,2) and c is the
invariant of the edge (1,2).  See kernel_code/edge_classes.c
for a detailed account of the convention used.</p>
<p>If the optional argument form=’rect’ is given, then this
function returns a list of tuples of the form:</p>
<blockquote>
<div><p>( [a0, a1,..,a_n], [b_0, b_1,…,b_n], c)</p>
</div></blockquote>
<p>where this corresponds to the equation</p>
<blockquote>
<div><p>z0^a0 (1 - z0)^b0 z1^a1(1 - z1)^b1 …  = c</p>
</div></blockquote>
<p>where c = 1 or -1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004(2,3)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">()</span>
<span class="go">[ 2  1  0  1  0  2]</span>
<span class="go">[ 0  1  2  1  2  0]</span>
<span class="go">[ 2  0  0  0 -8  6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">(</span><span class="n">form</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span>
<span class="go">[([2, -1], [-1, 2], 1), ([-2, 1], [1, -2], 1), ([2, -6], [0, 14], 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.gluing_equations_pgl">
<span class="sig-name descname"><span class="pre">gluing_equations_pgl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations_pgl" title="Permalink to this definition">¶</a></dt>
<dd><p>M.gluing_equations_pgl(N = 2, equation_type=’all’)</p>
<p>Returns a NeumannZagierTypeEquations object that contains a matrix
encoding the gluing equations for boundary-parabolic PGL(N,C)
representations together with explanations of the meaning
of the rows and the columns of the matrix.</p>
<p>This method generalizes gluing_equations() to PGL(N,C)-representations
as described in
Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert:
“Gluing Equations for PGL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>).</p>
<p>The result of the traditional gluing_equations() can be obtained from
the general method by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span>
<span class="go">[ 2  1  0  1  0  2]</span>
<span class="go">[ 0  1  2  1  2  0]</span>
<span class="go">[ 1  0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  0 -2  2]</span>
</pre></div>
</div>
<p>But besides the matrix, the method also returns explanations of
the columns and rows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span>
<span class="go">NeumannZagierTypeEquations(</span>
<span class="go">  [ 2  1  0  1  0  2]</span>
<span class="go">  [ 0  1  2  1  2  0]</span>
<span class="go">  [ 1  0  0  0 -1  0]</span>
<span class="go">  [ 0  0  0  0 -2  2],</span>
<span class="go">  explain_columns = [&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;],</span>
<span class="go">  explain_rows = [&#39;edge_0_0&#39;, &#39;edge_0_1&#39;, &#39;meridian_0_0&#39;, &#39;longitude_0_0&#39;])</span>
</pre></div>
</div>
<p>The first row of the matrix means that the edge equation for
edge 0 is</p>
<blockquote>
<div><p>z_0000_0 ^ 2 * zp_0000_0 * z_0000_1 * zpp_0000_1 ^ 2 = 1.</p>
</div></blockquote>
<p>Similarly, the next row encodes the edge equation for the other edge
and the next two rows encode peripheral equations.</p>
<p>Following the SnapPy convention, a z denotes the cross ratio z at the
edge (0,1), a zp the cross ratio z’ at the edge (0,2) and a zpp the cross
ratio z” at the edge (1,2). The entire symbol z_xxxx_y then
denotes the cross ratio belonging to the subsimplex at integral
point xxxx (always 0000 for N = 2) of the simplex y. Note: the
SnapPy convention is different from the paper
mentioned above, e.g., compare
kernel_code/edge_classes.c with Figure 3. We follow the SnapPy
convention here so that all computations done in SnapPy are
consistent.</p>
<p>The explanations of the rows and columns can be obtained explicitly by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">equation_type</span> <span class="o">=</span> <span class="s1">&#39;peripheral&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explain_rows</span>
<span class="go">[&#39;meridian_0_0&#39;, &#39;meridian_1_0&#39;, &#39;longitude_0_0&#39;, &#39;longitude_1_0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">explain_columns</span>
<span class="go">[&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;]</span>
</pre></div>
</div>
<p>A subset of all gluing equations can be obtained by setting the
equation_type:</p>
<ul class="simple">
<li><p>all gluing equations: ‘all’</p></li>
<li><p>non-peripheral equations: ‘non_peripheral’</p>
<ul>
<li><p>edge gluing equations: ‘edge’</p></li>
<li><p>face gluing equations: ‘face’</p></li>
<li><p>internal gluing equations: ‘internal’</p></li>
</ul>
</li>
<li><p>cusp gluing equations: ‘peripheral’</p>
<ul>
<li><p>cusp gluing equations for meridians: ‘meridian’</p></li>
<li><p>cusp gluing equations for longitudes: ‘longitude’</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.has_finite_vertices">
<span class="sig-name descname"><span class="pre">has_finite_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.has_finite_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if and only if the triangulation has finite (non-ideal)
vertices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When trying to find a hyperbolic structure, SnapPea will eliminate
finite vertices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">with_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.high_precision">
<span class="sig-name descname"><span class="pre">high_precision</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.high_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high precision version of this manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">high_precision</span><span class="p">())</span>
<span class="go">&lt;class &#39;snappy.ManifoldHP&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.holonomy_matrix_entries">
<span class="sig-name descname"><span class="pre">holonomy_matrix_entries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.holonomy_matrix_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>The entries of the matrices of the holonomy as list of ApproximateAlgebraicNumbers
(four consecutive numbers per matrix). The numbers are guaranteed to lie in the
trace field only if match_kernel = False:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">mat_entries</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">holonomy_matrix_entries</span><span class="p">(</span><span class="n">match_kernel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE +NUMERIC9</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">mat_entries</span>
<span class="o">&lt;</span><span class="n">SetOfAAN</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">3.4641016151377544</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">]</span><span class="o">&gt;</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">mat_entries</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">polynomial</span><span class="p">()</span>
<span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.homological_longitude">
<span class="sig-name descname"><span class="pre">homological_longitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.homological_longitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the peripheral curve in the given cusp, if any, which is
homologically trivial (with rational coefficients) in the manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>If no cusp is specified, the default is the first unfilled cusp;
if all cusps are filled, the default is the first cusp:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L5a1(3,4)(0,0)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The components of the next link have nontrivial linking number
so there is no such curve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">W</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L7a2&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">W</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">(</span><span class="n">cusp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>If every curve in the given cusp is trivial in the rational homology of
the manifold, an exception is raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;4_1(1,0)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Every</span> <span class="n">curve</span> <span class="n">on</span> <span class="n">cusp</span> <span class="ow">is</span> <span class="n">homologically</span> <span class="n">trivial</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.homology">
<span class="sig-name descname"><span class="pre">homology</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.homology" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AbelianGroup representing the first integral
homology group of the underlying (Dehn filled) manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">Z/5 + Z</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_SLN_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_SLN_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_SLN_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the torsion polynomial of the holonomy representation lifted
to SL(2, C) and then followed by the irreducible representation
from SL(2, C) -&gt; SL(N, C):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m016&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_SLN_torsion</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_adjoint_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_adjoint_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_adjoint_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the torsion polynomial of the adjoint representation
a la Dubois-Yamaguichi.   This is not a sign-refined computation
so the result is only defined up to sign, not to mention a power
of the variable ‘a’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K11n42&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_adjoint_torsion</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">Univariate</span> <span class="n">Polynomial</span> <span class="n">Ring</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">over</span> <span class="n">Complex</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">100</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="mi">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_lifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wada_conventions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the hyperbolic torsion polynomial as defined in
<a class="reference external" href="http://arxiv.org/abs/1108.3045">[DFJ]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K11n42&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="mi">1</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_torsion</span><span class="p">(</span><span class="n">bits_prec</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.identify">
<span class="sig-name descname"><span class="pre">identify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extends_to_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.identify" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for the manifold in all of the SnapPy databases:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m125(0,0)(0,0), L13n5885(0,0)(0,0), ooct01_00000(0,0)(0,0)]</span>
</pre></div>
</div>
<p>One can require that there be an isometry taking meridians
to meridians:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">extends_to_link</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[m125(0,0)(0,0), ooct01_00000(0,0)(0,0)]</span>
</pre></div>
</div>
<p>For closed manifolds, extends_to_link doesn’t make sense because
of how the kernel code works:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m015(1,2)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m006(-5,2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.init_hyperbolic_structure">
<span class="sig-name descname"><span class="pre">init_hyperbolic_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force_recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.init_hyperbolic_structure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.inside_view">
<span class="sig-name descname"><span class="pre">inside_view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cohomology_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.inside_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Show raytraced inside view of hyperbolic manifold:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">inside_view</span><span class="p">()</span> 
</pre></div>
</div>
<p>Or show the cohomology fractal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">inside_view</span><span class="p">(</span><span class="n">cohomology_class</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> 
</pre></div>
</div>
<p>The cohomology class in H^2(M, bd M; R) producing the cohomology
fractal can be specified as a cocycle or using an automatically computed
basis (of, say, length <code class="docutils literal notranslate"><span class="pre">n</span></code>). Thus, <code class="docutils literal notranslate"><span class="pre">cohomology_class</span></code> can be one of
the following.</p>
<ul class="simple">
<li><p>An integer <code class="docutils literal notranslate"><span class="pre">i</span></code> between 0 and <code class="docutils literal notranslate"><span class="pre">n</span></code> - 1 to pick the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th basis
vector.</p></li>
<li><p>An array of length <code class="docutils literal notranslate"><span class="pre">n</span></code> specifying the cohomology class as linear
combination of basis vectors.</p></li>
<li><p>A weight for each face of each tetrahedron.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.invariant_trace_field_gens">
<span class="sig-name descname"><span class="pre">invariant_trace_field_gens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.invariant_trace_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007(3,1)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">invariant_trace_field_gens</span><span class="p">()</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">L</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">trace_field_gens</span><span class="p">()</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">polynomial</span><span class="p">(),</span> <span class="n">L</span><span class="o">.</span><span class="n">polynomial</span><span class="p">()</span>
<span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_isometric_to">
<span class="sig-name descname"><span class="pre">is_isometric_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Manifold</span> <span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_isometries=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_isometric_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if M and N are isometric, False if they not.  A
RuntimeError is raised in cases where the SnapPea kernel fails
to determine either answer.  (This is fairly common for closed
manifolds.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can also get a complete list of isometries between the two
manifolds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>  <span class="c1"># The Whitehead link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m129&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">return_isometries</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># Includes action on cusps</span>
<span class="go">0 -&gt; 1  1 -&gt; 0 </span>
<span class="go">[1  2]  [-1 -2]</span>
<span class="go">[0 -1]  [ 0  1]</span>
<span class="go">Extends to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
<p>Note: The answer True is rigorous, but the answer False may
not be as there could be numerical errors resulting in finding
an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_orientable">
<span class="sig-name descname"><span class="pre">is_orientable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_orientable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the underlying 3-manifold is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;x124&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_two_bridge">
<span class="sig-name descname"><span class="pre">is_two_bridge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_two_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>If the manifold is the complement of a two-bridge knot or link
in S^3, then this method returns (p,q) where p/q is the
fraction describing the link.  Otherwise, returns False.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">(2, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m016&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: An answer of ‘True’ is rigorous, but not the answer
‘False’, as there could be numerical errors resulting in
finding an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.isometry_signature">
<span class="sig-name descname"><span class="pre">isometry_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">of_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_bits_precs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[53,</span> <span class="pre">212]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_bits_prec_and_degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[(212,</span> <span class="pre">10),</span> <span class="pre">(1000,</span> <span class="pre">20),</span> <span class="pre">(2000,</span> <span class="pre">20)]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.isometry_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>The isomorphism signature of the canonical retriangulation. This is a
complete invariant of the isometry type of a hyperbolic 3-manifold and
described in more detail <a class="reference external" href="verify.html#the-canonical-retriangulation-and-the-isometry-signature">here</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m125&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">()</span> <span class="c1"># Unverified isometry signature</span>
<span class="go">&#39;gLLPQccdefffqffqqof&#39;</span>
</pre></div>
</div>
<p>When used inside <a class="reference external" href="http://sagemath.org/">Sage</a> and <code class="docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> is
passed as argument, the verify module will certify the result to be
correct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m125&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># Verified isometry signature</span>
<span class="s1">&#39;gLLPQccdefffqffqqof&#39;</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">of_link</span> <span class="pre">=</span> <span class="pre">True</span></code> is specified, the peripheral curves are included in
such a way that the result is a complete invariant of a link. In particular,
<code class="docutils literal notranslate"><span class="pre">isometry_signature(of_link=True)</span></code> is invariant under changing the
ordering or orientations of the components or flipping all crossings of a
link simultaneously (it passes <code class="docutils literal notranslate"><span class="pre">ignore_cusp_order</span> <span class="pre">=</span> <span class="pre">True,</span>
<span class="pre">ignore_curve_orientations</span> <span class="pre">=</span> <span class="pre">True</span></code> to
<a class="reference internal" href="#snappy.Manifold.triangulation_isosig" title="snappy.Manifold.triangulation_isosig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.triangulation_isosig()</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;5^2_1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddhgggb_baCbbaCb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;7^2_8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddhgggb_bBcBbaCb&#39;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="verify_canon.html#snappy.verify.verified_canonical_retriangulation" title="snappy.verify.verified_canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify.verified_canonical_retriangulation()</span></code></a> for the
additional options.</p>
<p>Note that interval methods cannot verify a canonical retriangulation
with non-tetrahedral cells such as in the cas of <code class="docutils literal notranslate"><span class="pre">m412</span></code>, so the following
call returns <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">exact_bits_prec_and_degrees</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.isomorphisms_to">
<span class="sig-name descname"><span class="pre">isomorphisms_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Triangulation</span> <span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.isomorphisms_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a complete list of combinatorial isomorphisms between
the two triangulations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">([[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="go">0 -&gt; 1  1 -&gt; 0</span>
<span class="go">[ 1 0]  [-1 1]</span>
<span class="go">[-1 1]  [-3 2]</span>
<span class="go">Does not extend to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.length_spectrum">
<span class="sig-name descname"><span class="pre">length_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_rigor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.length_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>M.length_spectrum(cutoff=1.0)</p>
<p>Returns a list of geodesics (with multiplicities) of length
up to the specified cutoff value. (The default cutoff is 1.0.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.link">
<span class="sig-name descname"><span class="pre">link</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;4_1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.normal_boundary_slopes">
<span class="sig-name descname"><span class="pre">normal_boundary_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FXrays'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_boundary_slopes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a one-cusped manifold, returns all the nonempty boundary slopes of
spun normal surfaces.  Provided the triangulation supports a
genuine hyperbolic structure, then by <a class="reference external" href="http://arxiv.org/abs/math/0503027">Thurston and Walsh</a> any strict boundary slope
(the boundary of an essential surface which is not a fiber or
semifiber) must be listed here.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K3_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(16, -1), (20, -1), (37, -2)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">subset</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">'kabaya'</span></code>, then it only
returns boundary slopes associated to vertex surfaces with a quad
in every tetrahedron; by Theorem 1.1. of <a class="reference external" href="http://arxiv.org/abs/1102.4588">[DG]</a> these are all strict boundary
slopes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m113&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(1, 1), (1, 2), (2, -1), (2, 3), (8, 11)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s1">&#39;kabaya&#39;</span><span class="p">)</span>
<span class="go">[(8, 11)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">subset</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">'brasile'</span></code> then it returns
only the boundary slopes that are associated to vertex surfaces
giving isolated rays in the space of embedded normal surfaces.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s1">&#39;brasile&#39;</span><span class="p">)</span>
<span class="go">[(1, 2), (8, 11)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.normal_surfaces">
<span class="sig-name descname"><span class="pre">normal_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FXrays'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>All the vertex spun-normal surfaces in the current triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_surfaces</span><span class="p">()</span>    
<span class="go">[&lt;Surface 0: [0, 0] [1, 2] (4, 1)&gt;,</span>
<span class="go"> &lt;Surface 1: [0, 1] [1, 2] (4, -1)&gt;,</span>
<span class="go"> &lt;Surface 2: [1, 2] [2, 1] (-4, -1)&gt;,</span>
<span class="go"> &lt;Surface 3: [2, 2] [2, 1] (-4, 1)&gt;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.num_cusps">
<span class="sig-name descname"><span class="pre">num_cusps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusp_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.num_cusps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of cusps.  By giving the optional argument
‘orientable’ or ‘nonorientable’ it will only count cusps of that type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.num_tetrahedra">
<span class="sig-name descname"><span class="pre">num_tetrahedra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.num_tetrahedra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of tetrahedra in the triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.orientation_cover">
<span class="sig-name descname"><span class="pre">orientation_cover</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.orientation_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>For a non-orientable Triangulation, returns the 2-fold cover which
is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;x123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">orientation_cover</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">())</span>
<span class="go">(False, True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span>
<span class="go">x123~(0,0)(0,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="o">.</span><span class="n">cover_info</span><span class="p">()[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
<span class="go">&#39;cyclic&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.pickle">
<span class="sig-name descname"><span class="pre">pickle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.pickle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.plink">
<span class="sig-name descname"><span class="pre">plink</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.plink" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings up a link editor window if there is a link known to be associated
with the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.polished_holonomy">
<span class="sig-name descname"><span class="pre">polished_holonomy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lift_to_SL2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_solution_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.polished_holonomy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fundamental group of M equipt with a high-precision version of the
holonomy representation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">polished_holonomy</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
<span class="mf">1.5000000000000000000000000000</span> <span class="o">-</span> <span class="mf">0.86602540378443864676372317075</span><span class="o">*</span><span class="n">I</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">polished_holonomy</span><span class="p">(</span><span class="n">bits_prec</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">Complex</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">1000</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_generalized_obstruction_classes">
<span class="sig-name descname"><span class="pre">ptolemy_generalized_obstruction_classes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_generalized_obstruction_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>M.ptolemy_generalized_obstruction_classes(N)</p>
<p>Returns the obstruction classes needed to compute
PGL(N,C)-representations for any N, i.e., it returns a list with
a representative cocycle for each element in
H^2(M, boundary M; Z/N) / (Z/N)^* where (Z/N)^* are the units in Z/N.
The first element in the list always corresponds to the trivial
obstruction class.
The generalized ptolemy obstruction classes are thus a generalization
of the ptolemy obstruction classes that allow to find all
boundary-unipotent
PGL(N,C)-representations including those that do not lift to
boundary-unipotent SL(N,C)-representations for N odd or
SL(N,C)/{+1,-1}-representations for N even.</p>
<p>For example, 4_1 has three obstruction classes up to equivalence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>For 4_1, we only get three obstruction classes even though we have
H^2(M, boundary M; Z/4) = Z/4 because the two obstruction classes
1 in Z/4 and -1 in Z/4 are related by a unit and thus give
isomorphic Ptolemy varieties.</p>
<p>The primary use of an obstruction class sigma is to construct the
Ptolemy variety of sigma. This variety computes boundary-unipotent
PGL(N,C)-representations whose obstruction class to a
boundary-unipotent lift to SL(N,C) is sigma.</p>
<p>For example for 4_1, there are 2 obstruction classes for N = 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The Ptolemy variety parametrizing boundary-unipotent
SL(3,C)-representations of 4_1 is obtained by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Ptolemy variety parametrizing boundary-unipotent
PSL(3,C)-representations of 4_1 that do not lift to
boundary-unipotent SL(3,C)-representations is obtained by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The cocycle representing the non-trivial obstruction class looks as
follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyGeneralizedObstructionClass([2, 0, 0, 1])</span>
</pre></div>
</div>
<p>This means that the cocycle takes the value -1 in Z/3 on the first face
class and 1 on the fourth face class but zero on every other of the
four face classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_obstruction_classes">
<span class="sig-name descname"><span class="pre">ptolemy_obstruction_classes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_obstruction_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the obstruction classes needed to compute
pSL(N,C) = SL(N,C)/{+1,-1} representations for even N, i.e., it
returns a list with a representative cocycle for each class in
H^2(M, boundary M; Z/2). The first element in the list is always
representing the trivial obstruction class.</p>
<p>For example, 4_1 has two obstruction classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The primary use of these obstruction classes is to construct
the Ptolemy variety as described in Definition 1.7 of
Stavros Garoufalidis, Dylan Thurston, Christian K. Zickert:
“The Complex Volume of SL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>).</p>
<p>For example, to construct the Ptolemy variety for
PSL(2,C)-representations of 4_1 that do not lift to boundary-parabolic
SL(2,C)-representations, use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Or the following short-cut:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this obstruction class only makes sense for even N:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">PtolemyObstructionClass only makes sense for even N, try PtolemyGeneralizedObstructionClass</span>
</pre></div>
</div>
<p>To obtain PGL(N,C)-representations for N &gt; 2, use the generalized
obstruction class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The original obstruction class encodes a representing cocycle in Z/2 as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyObstructionClass(s_0_0 + 1, s_1_0 - 1, s_2_0 - 1, s_3_0 + 1, s_0_0 - s_0_1, s_1_0 - s_3_1, s_2_0 - s_2_1, s_3_0 - s_1_1)</span>
</pre></div>
</div>
<p>This means that the cocycle to represent this obstruction class in Z/2
takes value 1 in Z/2 on face 0 of tetrahedra 0 (because s_0_0 = -1)
and value 0 in Z/2 on face 1 of tetrahedra 0 (because s_1_0 = +1).</p>
<p>Face 3 of tetrahedra 0 and face 1 of tetrahedra 1 are identified,
hence the cocycle takes the same value on those two faces (s_3_0 = s_1_1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_variety">
<span class="sig-name descname"><span class="pre">ptolemy_variety</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obstruction_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eliminate_fixed_ptolemys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_variety" title="Permalink to this definition">¶</a></dt>
<dd><p>M.ptolemy_variety(N, obstruction_class = None, simplify = True, eliminate_fixed_ptolemys = False)</p>
<p>Returns a Ptolemy variety as described in</p>
<ul class="simple">
<li><p>Stavros Garoufalidis, Dyland Thurston, Christian K. Zickert:
“The Complex Volume of SL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>)</p></li>
<li><p>Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert:
“Gluing Equations for PGL(n,C)-Representations of 3-Manifolds ”
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>)</p></li>
</ul>
<p>The variety can be exported to magma or sage and solved there. The
solutions can be processed to compute invariants. The method can also
be used to automatically look up precomputed solutions from the
database at <a class="reference external" href="http://ptolemy.unhyperbolic.org/data">http://ptolemy.unhyperbolic.org/data</a> .</p>
<p>Example for m011 and PSL(2,C)-representations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m011&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Obtain all Ptolemy varieties for PSL(2,C)-representations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two Ptolemy varieties for the two obstruction classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Retrieve the solutions from the database</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">retrieve_solutions</span><span class="p">()</span> 
</pre></div>
</div>
<p>Compute the solutions using magma (default in SnapPy)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Compute the solutions using singular (default in sage)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;sage&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Note that magma is significantly faster.</p>
<p>Compute all resulting complex volumes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">complex_volume_numerical</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span>  
<span class="go">[[[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go">   -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go">   0.942707362776931 + 0.459731436553693*I]],</span>
<span class="go"> [[3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go">   4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go">   -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go">   2.78183391239608 - 0.496837853805869*I]]]</span>
</pre></div>
</div>
<p>Show complex volumes as a non-nested list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go"> -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go"> 4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go"> -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go"> 2.78183391239608 - 0.496837853805869*I]</span>
</pre></div>
</div>
<p>For more examples, go to <a class="reference external" href="http://ptolemy.unhyperbolic.org/">http://ptolemy.unhyperbolic.org/</a></p>
<p>=== Optional Arguments ===</p>
<p>obstruction_class — class from Definition 1.7 of (1).
None for trivial class or a value returned from ptolemy_obstruction_classes.
Short cuts: obstruction_class = ‘all’ returns a list of Ptolemy varieties
for each obstruction. For easier iteration, can set obstruction_class to
an integer.</p>
<p>simplify — boolean to indicate whether to simplify the equations which
significantly reduces the number of variables.
Simplifying means that several identified Ptolemy coordinates x = y = z = …
are eliminated instead of adding relations x - y = 0, y - z = 0, …</p>
<p>eliminate_fixed_ptolemys — boolean to indicate whether to eliminate
the Ptolemy coordinates that are set to 1 for fixing the decoration.
Even though this simplifies the resulting representation, setting it to
True can cause magma to run longer when finding a Groebner basis.</p>
<p>=== Examples for 4_1 ===</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the varieties for all obstruction classes at once (use
help(varieties[0]) for more information):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Print the variety as an ideal (sage object) for the non-trivial class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ideal</span>    
<span class="go">Ideal (-c_0011_0^2 + c_0011_0*c_0101_0 + c_0101_0^2, -c_0011_0^2 - c_0011_0*c_0101_0 + c_0101_0^2, c_0011_0 - 1) of Multivariate Polynomial Ring in c_0011_0, c_0101_0 over Rational Field</span>
</pre></div>
</div>
<p>Print the equations of the variety for the non-trivial class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">equations</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>          
<span class="go">     - c_0011_0 * c_0101_0 + c_0011_0^2 + c_0101_0^2</span>
<span class="go">     c_0011_0 * c_0101_0 - c_0011_0^2 - c_0101_0^2</span>
<span class="go">     - 1 + c_0011_0</span>
</pre></div>
</div>
<p>Generate a magma file to compute Primary Decomposition for N = 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">to_magma</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;ring and ideal&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>     
<span class="go">R&lt;c_0012_0, c_0012_1, c_0102_0, c_0111_0, c_0201_0, c_1011_0, c_1011_1, c_1101_0&gt; := PolynomialRing(RationalField(), 8, &quot;grevlex&quot;);</span>
<span class="go">MyIdeal := ideal&lt;R |</span>
<span class="go">          c_0012_0 * c_1101_0 + c_0102_0 * c_0111_0 - c_0102_0 * c_1011_0,</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>=== If you have a magma installation ===</p>
<p>Call p.compute_solutions() to automatically call magma on the above output
and produce exact solutions!!!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># magma failed, use precomputed_solutions</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>Check solutions against manifold
&gt;&gt;&gt; if sols:
…     dummy = sols.check_against_manifold()</p>
<p>=== If you do not have a magma installation ===</p>
<p>Load a precomputed example from magma which is provided with the package:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">snappy.ptolemy.processMagmaFile</span> <span class="kn">import</span> <span class="n">_magma_output_for_4_1__sl3</span><span class="p">,</span> <span class="n">solutions_from_magma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>      

<span class="go">==TRIANGULATION=BEGINS==</span>
<span class="go">% Triangulation</span>
<span class="go">4_1</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Parse the file and produce solutions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">solutions_from_magma</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dummy</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">check_against_manifold</span><span class="p">()</span>
</pre></div>
</div>
<p>=== Continue here whether you have or do not have magma ===</p>
<p>Pick the first solution of the three different solutions (up to Galois
conjugates):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span> <span class="o">=</span> <span class="n">sols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Read the exact value for c_1020_0 (help(solution) for more information
on how to compute cross ratios, volumes and other invariants):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;c_1020_0&#39;</span><span class="p">]</span>
<span class="go">Mod(-1/2*x - 3/2, x^2 + 3*x + 4)</span>
</pre></div>
</div>
<p>Example of simplified vs non-simplified variety for N = 4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">simplified</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">full</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">simplify</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
<span class="go">(21, 63)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">equations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">equations</span><span class="p">)</span>
<span class="go">(24, 72)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.randomize">
<span class="sig-name descname"><span class="pre">randomize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blowup_multiple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passes_at_fours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.randomize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform random Pachner moves on the underlying triangulation,
including some intial 3 -&gt; 2 moves that increase the number of
tetrahedra by blowup_multiple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;Braid:[1,2,-3,-3,1,2]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.reverse_orientation">
<span class="sig-name descname"><span class="pre">reverse_orientation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.reverse_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the orientation of the Triangulation, presuming that
it is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">reverse_orientation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cs</span> <span class="o">+</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()),</span> <span class="mi">15</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the triangulation as a SnapPea triangulation file.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;fig-eight.tri&#39;</span><span class="p">)</span>     
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_name">
<span class="sig-name descname"><span class="pre">set_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the triangulation a new name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;figure-eight-comp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">figure-eight-comp(0,0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_peripheral_curves">
<span class="sig-name descname"><span class="pre">set_peripheral_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peripheral_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_peripheral_curves" title="Permalink to this definition">¶</a></dt>
<dd><p>Each cusp has a preferred marking. In the case of a torus
cusp, this is pair of essential simple curves meeting in one
point; equivalently, a basis of the first homology of the
boundary torus. These curves are called the meridian and the
longitude.</p>
<p>This method changes these markings in various ways.  In many
cases, if the flag return_matrices is True then it returns
a list of change-of-basis matrices is returned, one per
cusp, which will restore the original markings if passed
as peripheral_data.</p>
<ul>
<li><p>Make the shortest curves the meridians, and the second
shortest curves the longitudes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-2.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s1">&#39;shortest&#39;</span><span class="p">,</span> <span class="n">return_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-0.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span>
<span class="go">[[[1, 0], [-2, 1]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">cob</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-2.49024467 + 2.97944707*I]</span>
</pre></div>
</div>
<p>You can also make just the meridians as short as 
possible while fixing the longitudes via the option
‘shortest_meridians’, and conversely with
‘shortest_longitudes’.</p>
</li>
<li><p>If cusps are Dehn filled, make those curves meridians.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125(0,0)(2,5)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s1">&#39;fillings&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(1,0)</span>
</pre></div>
</div>
</li>
<li><p>Change the basis of a particular cusp, say the first one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">]</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here (1,2) is the new meridian written in the old basis, and
(1,3) the new longitude.</p>
</li>
<li><p>Change the basis of all the cusps at once</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_curves</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>  <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">new_curves</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(-1,-2)</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_target_holonomy">
<span class="sig-name descname"><span class="pre">set_target_holonomy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_target_holonomy" title="Permalink to this definition">¶</a></dt>
<dd><p>M.set_target_holonomy(target, which_cusp=0, recompute=True)</p>
<p>Computes a geometric structure in which the Dehn filling curve
on the specified cusp has holonomy equal to the target value.
The holonomies of Dehn filling curves on other cusps are left
unchanged.  If the ‘recompute’ flag is False, the Dehn filling
equations are modified, but not solved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_tetrahedra_shapes">
<span class="sig-name descname"><span class="pre">set_tetrahedra_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filled_shapes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_shapes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_tetrahedra_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the tetrahedron shapes with those in the given lists,
and sets the Dehn filling coefficients as specified by the
fillings argument.  The shapes will get double precision
values; polishing will be needed for high precision shapes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.short_slopes">
<span class="sig-name descname"><span class="pre">short_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trigDependentTryCanonize'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.short_slopes" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks disjoint cusp neighborhoods (using
<a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.cusp_areas()</span></code></a>, thus the same arguments can be
used) and returns for each cusp the slopes that have length less
or equal to given <code class="docutils literal notranslate"><span class="pre">length</span></code> (defaults to 6) when measured on the
boundary of the cusp neighborhood:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;otet20_00022&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">()</span>
<span class="go">[[(1, 0), (-1, 1), (0, 1)], [(1, 0)]]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">verified=True</span></code>, the result is guaranteed
to contain all slopes of length less or equal to given <code class="docutils literal notranslate"><span class="pre">length</span></code>
(and could contain additional slopes if precision is not high
enough):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]]</span>
</pre></div>
</div>
<p>The ten exceptional slopes of the figure-eight knot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">()</span>
<span class="go">[[(1, 0), (-4, 1), (-3, 1), (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]]</span>
</pre></div>
</div>
<p>Two more slopes appear when increasing length to 2 pi:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">length</span> <span class="o">=</span> <span class="mf">6.283185307179586</span><span class="p">)</span>
<span class="go">[[(1, 0), (-5, 1), (-4, 1), (-3, 1), (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]]</span>
</pre></div>
</div>
<p>When using verified computations, <code class="docutils literal notranslate"><span class="pre">length</span></code> is converted into the <code class="docutils literal notranslate"><span class="pre">RealIntervalField</span></code> of requested precision:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">,</span> <span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">bits_prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> 
<span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">passes_at_fours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to simplify the triangulation by doing Pachner moves.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;12n123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</pre></div>
</div>
<p>It does four kinds of moves that reduce the number of
tetrahedra:</p>
<ul class="simple">
<li><p>3 -&gt; 2 and 2 -&gt; 0 Pacher moves, which eliminate one or two
tetrahedra respectively.</p></li>
<li><p>On suitable valence-1 edges, does a 2 -&gt; 3 and then 2 -&gt; 0 move,
which removes a tetrahedron and creates a new valence-1 edge.</p></li>
<li><p>When a 2-simplex has two edges of valence-4 giving rise to the
suspension of a pentagon, replace these 6 tetrahedra with a
single edge of valence 5.</p></li>
</ul>
<p>It also does random 4 -&gt; 4 moves in hopes of setting up a
simplfication.  The argument passes_at_fours is the number of
times it goes through the valence-4 edges without progress 
before giving up.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.slice_obstruction_HKL">
<span class="sig-name descname"><span class="pre">slice_obstruction_HKL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">primes_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_in_S3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.slice_obstruction_HKL" title="Permalink to this definition">¶</a></dt>
<dd><p>For the exterior of a knot in S^3, searches for a topological
slicing obstruction from:</p>
<p>Herald, Kirk, Livingston, Math Zeit., 2010
<a class="reference external" href="https://dx.doi.org/10.1007/s00209-009-0548-1">https://dx.doi.org/10.1007/s00209-009-0548-1</a>
<a class="reference external" href="https://arxiv.org/abs/0804.1355">https://arxiv.org/abs/0804.1355</a></p>
<p>The test looks at the cyclic branched covers of the knot of prime
order p and the F_q homology thereof where q is an odd prime. The
range of such (p, q) pairs searched is given by primes_spec as a
list of (p_max, [q_min, q_max]).  It returns the pair (p, q) of
the first nonzero obstruction found (in which case K is not
slice), and otherwise returns None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K12n813&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">spec</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">]),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">...</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">...</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">...</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>If primes_spec is just a pair (p, q) then only that obstruction is
checked:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>Technical note: As implemented, can only get an obstruction when
the decomposition of H_1(cover; F_q) into irreducible Z/pZ-modules
has no repeat factors.  The method of [HKL] can be used more
broadly, but other cases requires computing many more twisted
Alexander polynomials.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.solution_type">
<span class="sig-name descname"><span class="pre">solution_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.solution_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the current solution to the gluing
equations, basically a summary of how degenerate the solution
is.  If the flag enum=True is set, then an integer value is
returned. The possible answers are:</p>
<ul class="simple">
<li><p>0: ‘not attempted’</p></li>
<li><p>1: ‘all tetrahedra positively oriented’ aka ‘geometric_solution’
Should correspond to a genuine hyperbolic structure.</p></li>
<li><p>2: ‘contains negatively oriented tetrahedra’ aka ‘nongeometric_solution’
Probably corresponds to a hyperbolic structure but some
simplices have reversed orientations.</p></li>
<li><p>3: ‘contains flat tetrahedra’ All tetrahedra have shape in R - {0, 1}.</p></li>
<li><p>4: ‘contains degenerate tetrahedra’ Some shapes are close to
{0,1, or infinity}.</p></li>
<li><p>5: ‘unrecognized solution type’</p></li>
<li><p>6: ‘no solution found’</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains negatively oriented tetrahedra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains degenerate tetrahedra&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">which_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the manifold open along a surface of positive characteristic found
by the method “splitting_surfaces”.  Returns a list of the pieces, with any 
sphere boundary components filled in.</p>
<p>Here’s an example of a Whitehead double on the trefoil.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K14n26039&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Orientable two-sided with euler = 0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="n">pieces</span>
<span class="go">[K14n26039.a(0,0)(0,0), K14n26039.b(0,0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">3.66386238</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span><span class="o">.</span><span class="n">relators</span><span class="p">()</span>
<span class="go">[&#39;aabbb&#39;]</span>
</pre></div>
</div>
<p>You can also specify a surface by its index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L10n111&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
<span class="go">5.33348957</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.splitting_surfaces">
<span class="sig-name descname"><span class="pre">splitting_surfaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.splitting_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for connected closed normal surfaces of nonnegative Euler
characteristic.  If spheres or projective planes are found, then
tori and Klein bottles aren’t reported.  There is no guarantee
that all such normal surfaces will be found nor that any given
surface is incompressible.  The search is confined to surfaces
whose quads are in the tetrahedra that have degenerate shapes.</p>
<p>You can split the manifold open along one of these surfaces
using the method “split”.</p>
<p>A connect sum of two trefoils:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;DT: fafBCAEFD&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>First satellite knot in the table.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K13n4587&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()</span>
<span class="go">[Orientable two-sided with euler = 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.symmetric_triangulation">
<span class="sig-name descname"><span class="pre">symmetric_triangulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symmetric_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Dehn filling description of the manifold realizing
the symmetry group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m003(-3,1)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">()</span>
<span class="go">D6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">symmetric_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m003(1,0)(1,0)(1,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">(</span><span class="n">of_link</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">D6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.symmetry_group">
<span class="sig-name descname"><span class="pre">symmetry_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">of_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symmetry_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the symmetry group of the Manifold.
If the flag “of_link” is set, then it only returns symmetries
that preserves the meridians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.tetrahedra_field_gens">
<span class="sig-name descname"><span class="pre">tetrahedra_field_gens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The shapes of the tetrahedra as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&#39;m015&#39;)
sage: tets = M.tetrahedra_field_gens()
sage: tets.find_field(100, 10, optimize=True)    # doctest: +NORMALIZE_WHITESPACE +NUMERIC9
(Number Field in z with defining polynomial x^3 - x - 1
 with z = -0.6623589786223730? - 0.5622795120623013?*I,
&lt;ApproxAN: -0.662358978622 - 0.562279512062*I&gt;, [-z, -z, -z])
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.tetrahedra_shapes">
<span class="sig-name descname"><span class="pre">tetrahedra_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">part</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the shapes of the tetrahedra in the current solution to
the gluing equations.  Returns a list containing one info object
for each tetrahedron.  The keys are:</p>
<ul class="simple">
<li><p>rect : the shape of the tetrahedron, as a point in the
complex plane.</p></li>
<li><p>log : the log of the shape</p></li>
<li><p>accuracies: a list of the approximate accuracies of the
shapes, in order (rect re, rect im, log re, log im)</p></li>
</ul>
<p>If the optional variable ‘part’ is set to one of the above,
then the function returns only that component of the data.</p>
<p>If the flag ‘fixed_alignment’ is set to False, then the edges
used to report the shape parameters are chosen so as to
normalize the triangle.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">(</span><span class="n">part</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span>
<span class="go">[0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">()</span> 
<span class="go">[{&#39;accuracies&#39;: (11, 11, 12, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.trace_field_gens">
<span class="sig-name descname"><span class="pre">trace_field_gens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.trace_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">traces</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">trace_field_gens</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">traces</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="p">(</span><span class="n">Number</span> <span class="n">Field</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">with</span> <span class="n">defining</span> <span class="n">polynomial</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
 <span class="k">with</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="o">&lt;</span><span class="n">ApproxAN</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">I</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">[</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.triangulation_isosig">
<span class="sig-name descname"><span class="pre">triangulation_isosig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decorated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_cusp_ordering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_curve_orientations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.triangulation_isosig" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a compact text representation of the triangulation, called a
“decorated isomorphism signature”</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;cPcbbbiht_BaCB&#39;</span>
</pre></div>
</div>
<p>You can use this string to recreate an isomorphic triangulation later</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;y233&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;hLMzMkbcdefggghhhqxqhx_BaaB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;hLMzMkbcdefggghhhqxqhx_BaaB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, the returned string encodes the peripheral curves (and
slopes of Dehn-fillings if any are present), but you can request
only the “isomorphism signature” which can be given to
<a class="reference external" href="http://regina.sf.net/">Regina</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;K3_1&#39;</span><span class="p">)</span>   <span class="c1"># the (-2, 3, 7) exterior</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isosig</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span> <span class="o">=</span> <span class="kc">False</span><span class="p">);</span> <span class="n">isosig</span>
<span class="go">&#39;dLQacccjsnk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="n">isosig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">F</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">0 -&gt; 0</span>
<span class="go">[1 18]</span>
<span class="go">[0  1]</span>
<span class="go">Extends to link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;dLQacccjsnk_BaRsB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;dLQacccjsnk_BaaB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;dLQacccjsnk_BaRsB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0 -&gt; 0</span>
<span class="go">[1 0] </span>
<span class="go">[0 1] </span>
<span class="go">Extends to link</span>
</pre></div>
</div>
<p>If you do not care about the indexing of the cusps when using a
decorated signature, use ignore_cusp_ordering</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;L14n64110(1,2)(2,3)(-2,1)(3,4)(0,0)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isosig</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ignore_cusp_ordering</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isosig</span>
<span class="go">&#39;xLLvLvMLPMPLAMQQcceflnjmmmospsrttvvvtswwwiieiifdeauinasltltahmbjn_bacBbaaBBaBbBbbaabba(2,3)(-2,1)(1,2)(3,4)(0,0)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="n">isosig</span><span class="p">)</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you do not care about the orientations of the peripheral curves,
use ignore_curve_orientations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;L6a1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;gLLAQcdeefffdopuado_BabbBaab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isosig</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ignore_curve_orientations</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isosig</span>
<span class="go">&#39;gLLAQcdeefffdopuado_babbbaab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="n">isosig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">[0 -&gt; 0  1 -&gt; 1</span>
<span class="go">[-1 0]  [-1 0]</span>
<span class="go">[ 0 1]  [ 0 1]</span>
<span class="go">Extends to link, 0 -&gt; 0  1 -&gt; 1</span>
<span class="go">[1  0]  [1  0]</span>
<span class="go">[0 -1]  [0 -1]</span>
<span class="go">Extends to link]</span>
</pre></div>
</div>
<p>The code has been copied from <a class="reference external" href="http://regina.sf.net/">Regina</a> where
the corresponding method is called “isoSig”.</p>
<p>Unlike dehydrations for 3-manifold triangulations, an
isomorphism signature uniquely determines a triangulation up
to combinatorial isomorphism.  That is, two triangulations of
3-dimensional manifolds are combinatorially isomorphic if and
only if their isomorphism signatures are the same string.  For
full details, see <a class="reference external" href="http://arxiv.org/abs/1110.6080">Simplification paths in the Pachner graphs
of closed orientable 3-manifold triangulations, Burton, 2011</a>.</p>
<p>For details about how the peripheral decorations work, see
the SnapPy source code.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.use_field_conversion">
<span class="sig-name descname"><span class="pre">use_field_conversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.use_field_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>A class method for specifying a numerical conversion function.</p>
<p>SnapPy includes its own number type, snappy.Number, which can
represent floating point real or complex numbers of varying
precision.  (In fact, Number is a wrapper for a pari number of
type ‘t_INT’, ‘t_FRAC’, ‘t_REAL’ or ‘t_COMPLEX’, and the pari
gen can be extracted as an attribute: x.gen .)  Methods of
SnapPy objects which return numerical values will first compute
the value as a Number, and then optionally convert the Number
to a different numerical type which can be specified by calling
this class method.</p>
<p>By default SnapPy returns Numbers when loaded into python, and
elements of a Sage RealField or ComplexField when loaded into
Sage.  These will be 64 bit numbers for ordinary Manifolds and
212 bit numbers for high precision manifolds.</p>
<p>The func argument should be a function which accepts a number and
returns a numerical type of your choosing.  Alternatively, the
strings ‘sage’ or ‘snappy’ can be passed as arguments to select
either of the two default behaviors.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">())</span>
<span class="n">Real</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">64</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Manifold</span><span class="o">.</span><span class="n">use_field_conversion</span><span class="p">(</span><span class="s1">&#39;snappy&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">())</span>
<span class="n">SnapPy</span> <span class="n">Numbers</span> <span class="k">with</span> <span class="mi">64</span> <span class="n">bits</span> <span class="n">precision</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Manifold</span><span class="o">.</span><span class="n">use_field_conversion</span><span class="p">(</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">())</span>
<span class="n">Real</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">64</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.verify_hyperbolicity">
<span class="sig-name descname"><span class="pre">verify_hyperbolicity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holonomy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lift_to_SL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.verify_hyperbolicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an orientable SnapPy Manifold, verifies its hyperbolicity.
Similar to HIKMOT’s <a class="reference internal" href="#snappy.Manifold.verify_hyperbolicity" title="snappy.Manifold.verify_hyperbolicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify_hyperbolicity()</span></code></a>, the result is either
<code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">listOfShapeIntervals)</span></code> or <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">[])</span></code> if verification failed.
<code class="docutils literal notranslate"><span class="pre">listOfShapesIntervals</span></code> is a list of complex intervals (elements in
sage’s <code class="docutils literal notranslate"><span class="pre">ComplexIntervalField</span></code>) certified to contain the true shapes
for the hyperbolic manifold.</p>
<p>Higher precision intervals can be obtained by setting <code class="docutils literal notranslate"><span class="pre">bits_prec</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: M.verify_hyperbolicity() # doctest: +NUMERIC12
(True, [0.780552527850? + 0.914473662967?*I, 0.780552527850? + 0.91447366296773?*I, 0.4600211755737? + 0.6326241936052?*I])

sage: M = Manifold(&quot;t02333(3,4)&quot;)
sage: M.verify_hyperbolicity() # doctest: +NUMERIC9
(True, [2.152188153612? + 0.284940667895?*I, 1.92308491369? + 1.10360701507?*I, 0.014388591584? + 0.143084469681?*I, -2.5493670288? + 3.7453498408?*I, 0.142120333822? + 0.176540027036?*I, 0.504866865874? + 0.82829881681?*I, 0.50479249917? + 0.98036162786?*I, -0.589495705074? + 0.81267480427?*I])
</pre></div>
</div>
<p>One can instead get a holonomy representation associated to the
verified hyperbolic structure.  This representation takes values
in 2x2 matrices with entries in the <code class="docutils literal notranslate"><span class="pre">ComplexIntervalField</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m004(1,2)&quot;)
sage: success, rho = M.verify_hyperbolicity(holonomy=True)
sage: success
True
sage: trace = rho(&#39;aaB&#39;).trace(); trace # doctest: +NUMERIC9
-0.1118628555? + 3.8536121048?*I
sage: (trace - 2).contains_zero()
False
sage: (rho(&#39;aBAbaabAB&#39;).trace() - 2).contains_zero()
True
</pre></div>
</div>
<p>Here, there is <strong>provably</strong> a fixed holonomy representation rho0
from the fundamental group G of M to SL(2, C) so that for each
element g of G the matrix rho0(g) is contained in rho(g).  In
particular, the above constitutes a proof that the word ‘aaB’ is
non-trivial in G.  In contrast, the final computation is
consistent with ‘aBAbaabAB’ being trivial in G, but <em>does not prove
this</em>.</p>
<p>A non-hyperbolic manifold (<code class="docutils literal notranslate"><span class="pre">False</span></code> indicates that the manifold
might not be hyperbolic but does <strong>not</strong> certify
non-hyperbolicity. Sometimes, hyperbolicity can only be verified
after increasing the precision):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1(1,0)&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">verify_hyperbolicity</span><span class="p">()</span>
<span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">[])</span>
</pre></div>
</div>
<p>Under the hood, the function will call the <code class="docutils literal notranslate"><span class="pre">CertifiedShapesEngine</span></code> to produce
intervals certified to contain a solution to the rectangular gluing equations.
It then calls <code class="docutils literal notranslate"><span class="pre">check_logarithmic_gluing_equations_and_positively_oriented_tets</span></code>
to verify that the logarithmic gluing equations are fulfilled and that all
tetrahedra are positively oriented.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.volume">
<span class="sig-name descname"><span class="pre">volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the volume of the current solution to the hyperbolic
gluing equations; if the solution is sufficiently non-degenerate,
this is the sum of the volumes of the hyperbolic pieces in
the geometric decomposition of the manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">2.02988321</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which is the
number of digits of accuracy as <em>estimated</em> by SnapPea.  When
printing the volume, the result is rounded to 1 more than this
number of digits.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">.</span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">63</span><span class="p">)</span> <span class="c1"># Low precision, High precision</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Inside SageMath, verified computation of the volume of a
hyperbolic manifold is also possible (this will verify first
that the manifold is indeed hyperbolic):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.volume(verified=True, bits_prec=100)   #doctest: +NUMERIC24
2.029883212819307250042405109?
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.with_hyperbolic_structure">
<span class="sig-name descname"><span class="pre">with_hyperbolic_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.with_hyperbolic_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a (possibly degenerate) hyperbolic structure, turning the
Triangulation into a Manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">with_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">2.02988321</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.without_hyperbolic_structure">
<span class="sig-name descname"><span class="pre">without_hyperbolic_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.without_hyperbolic_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self as a Triangulation, forgetting the hyperbolic
structure in the process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">without_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;volume&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="snappy.html"
                        title="previous chapter">The snappy module and its classes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="manifoldhp.html"
                        title="next chapter">ManifoldHP: High-precision variant</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/manifold.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifoldhp.html" title="ManifoldHP: High-precision variant"
             >next</a> |</li>
        <li class="right" >
          <a href="snappy.html" title="The snappy module and its classes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 3.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="snappy.html" >The snappy module and its classes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Manifold: the main class</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2021, by Marc Culler, Nathan Dunfield, Matthias Goerner, Jeffrey Weeks and others.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>